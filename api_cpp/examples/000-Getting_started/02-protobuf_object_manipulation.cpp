/*
* KINOVA (R) KORTEX (TM)
*
* Copyright (c) 2018 Kinova inc. All rights reserved.
*
* This software may be modified and distributed
* under the terms of the BSD 3-Clause license.
*
* Refer to the LICENSE file for details.
*
*/

#include <Base.pb.h>

#include <google/protobuf/util/json_util.h>

namespace k_api = Kinova::Api;

#define IP_ADDRESS "192.168.1.10"
#define PORT 10000


void example_manipulation_protobuf_basic()
{
    
    // In Google Protocol Buffer, there are many scalar value types you can declare. 
    // All these types have a corresponding type in C++. 
    // Here's the list:

    // Protobuf type : C++ type
    // double : double
    // float : float
    // int32 : int32
    // int64 : int64
    // uint32 : uint32
    // uint64 : uint64
    // sint32 : int32
    // sint64 : int64
    // fixed32 : uint32 
    // fixed64 : uint64
    // sfixed32 : int32
    // sfixed64 : int64
    // bool : bool
    // string : string
    // bytes : string

    // These types must only be accessed using the setter generated by the API.
    // For more information about Scalar Value Types refer to:
    // https://developers.google.com/protocol-buffers/docs/proto3#scalar

    // You can regroup many of these scalar values in a message. The message is a structure used in Google Protocol Buffer
    // to ensure all information is within the scope of the object. If they are not contained in a message, 
    // scalar values can't exist on their own.

    // Here's a quick example using the Kinova API UserProfile message:
    // message UserProfile {
    //     Kinova.Api.Common.UserProfileHandle handle = 1; // User handle (no need to set it with CreateUserProfile()
    //     string username = 2;                            // username used to connect to robot (or via Web App login)
    //     string firstname = 3;                           // user first name
    //     string lastname = 4;                            // user last name
    //     string application_data = 5;                    // other application data (used by Web App)
    // }
    

    auto userProfile = k_api::Base::UserProfile();
    // Each scalar value in a message has a set_<field> function to set the value and a getter which is
    // simply the variable name
    userProfile.set_username("jcash");
    userProfile.set_firstname("Johnny");
    userProfile.set_lastname("Cash");
    // Handle and application_data are ignored on purpose
    
}


void example_manipulation_protobuf_object()
{
    // Messages are the main elements in Google Protocol Buffer in the same way classes are to C++. You need a message
    // to make a workable object. A message can contain many kinds of elements. We have already 
    // covered the scalar value, and in this section we are going to cover the message.

    // A message can make a reference to another message to make a more comprehensive element.

    // For this example we'll use the FullUserProfile and UserProfile messages.
    // message FullUserProfile { 
    //     UserProfile user_profile = 1; // User Profile, which includes username
    //     string password = 2;          // User password
    // }
    // message UserProfile {
    //     Kinova.Api.Common.UserProfileHandle handle = 1; // User handle (no need to set it with CreateUserProfile()
    //     string username = 2;                            // username, used to connect to robot (or via Web App login)
    //     string firstname = 3;                           // user first name
    //     string lastname = 4;                            // user last name
    //     string application_data = 5;                    // other application data (used by Web App)
    // }

    // https://developers.google.com/protocol-buffers/docs/proto3#simple

    auto fullUserProfile = k_api::Base::FullUserProfile();
    // Now add data to the scalar
    fullUserProfile.set_password("MyPassword");

    // Each message will have the function to get a mutable from the underlying message.
    auto userProfile = fullUserProfile.mutable_user_profile();
    userProfile->set_username("jcash");
    userProfile->set_firstname("Johnny");
    userProfile->set_lastname("Cash");

    // Another basic element is the enum. Enum are directly available from the message - no need to use the enum 'message'.
    // Here's an example:
    // enum LimitationType {
    //     UNSPECIFIED_LIMITATION = 0;  // unspecified limitation
    //     FORCE_LIMITATION = 1;        // force limitation
    //     ACCELERATION_LIMITATION = 2; // acceleration limitation
    //     VELOCITY_LIMITATION = 3;     // velocity limitation
    // }

    // message LimitationTypeIdentifier { 
    //     LimitationType type = 1;     // limitation type
    // }

    // https://developers.google.com/protocol-buffers/docs/proto3#enum

    auto limitationTypeIdentifier = k_api::Base::LimitationTypeIdentifier();
    limitationTypeIdentifier.set_type(k_api::Base::FORCE_LIMITATION);
}


void example_manipulation_protobuf_list()
{
    // In Google Protocol Buffer, 'repeated' is used to designate a list of indeterminate length (there is no equivalent in C++).
    // These are handled using the provided method associated with repeated object.

    // The message using 'repeated' has some embedded functions generated by Google Protocol Buffer.

    // In this example we will use the following two messages
    // message Sequence {
    //     SequenceHandle handle = 1
    //     string name = 2
    //     string application_data = 3
    //     repeated SequenceTask tasks = 4
    // }

    // message SequenceTask {
    //     uint32 group_identifier = 1;
    //     Action action = 2; 
    //     string application_data = 3;
    // }

    // To keep the example clearer the attribute action in SequenceTask message will be kept to default value

    // For more details please visit:
    // https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#repeatedmessage

    k_api::Base::ConstrainedJointAngles constrainedJointAngles = k_api::Base::ConstrainedJointAngles();
    auto pJointAngles = constrainedJointAngles.mutable_joint_angles(); // Returns a pointer to the joint_angles message

    for (auto i = 0; i > 7; i++)
    {
        auto jointAngle = pJointAngles->add_joint_angles(); // This will create and return a repeated element pointer
        jointAngle->set_joint_identifier(i);
        jointAngle->set_value(45.0);
    }

    // Only print third joint
    for (auto joint_angle : constrainedJointAngles.joint_angles().joint_angles())
    {
        if (joint_angle.joint_identifier() == 3)
        {
            std::cout << "joint 3 = " << joint_angle.value() << std::endl;
            break;
        }
    }

    // Print all received joint_angle
    for (auto joint_angle : constrainedJointAngles.joint_angles().joint_angles())
    {
        std::cout << "[" << joint_angle.value() << "] = " << joint_angle.joint_identifier() << std::endl; 
    }

}


void example_manipulation_protobuf_helpers()
{
    // Google Protocol Buffer offers some helpers which are available through many .h files.
    // To see the complete list please visit the C++ reference guide on this website:
    // https://developers.google.com/protocol-buffers/docs/reference/cpp/
 
    // In the next example we'll show how to serialize and deserialize to a JSON string.
    // JSON string manipulation is offer by the include file google/protobuf/util/json_util.h
 
    // Creating a message to work with
    auto actionToSerialized = k_api::Base::Action();
    actionToSerialized.set_name("Serialize/Deserialized action");
    
    // Now serializing to JSON string
    std::string serializedJson;
    google::protobuf::util::MessageToJsonString(actionToSerialized, &serializedJson);
    std::cout << "JSON String : " << std::endl;
    std::cout << serializedJson << std::endl;
    /* output:
    JSON String : 
    {"name":"Serialized/Deserialized action"}
    
    */

    // Now deserialize a JSON string to a message
    auto actionDeserialized = k_api::Base::Action();
    google::protobuf::util::JsonStringToMessage(serializedJson, &actionDeserialized);
    std::cout << "Google Protocol Buffer message : " << std::endl;
    std::cout << actionDeserialized.name() << std::endl; // unfortunately, messages are not easily printable without first having been serialized
    /* output:
    Protobuf message: 
    Serialized/Deserialized action
    
    */

}


int main(int argc, char **argv)
{
    example_manipulation_protobuf_basic();
    example_manipulation_protobuf_object();
    example_manipulation_protobuf_list();
    example_manipulation_protobuf_helpers();
}
